---
layout: post
title:  "typed-front-to-backend-communication"
caption: "Год без JS runtime errors"
date:   2018-01-15 11:00:00 +0300
categories: typescript 
---

# Год без JS runtime errors

### Получаем клиентский слой взаимодействия с API бесплатно вместе с контролем типов 

Краткая суть: выражаем все взаимодействие между клиентом и сервером в виде API-контроллеров, по ним генерируем все контракты передаваемых объектов, и по ним же генерируем клиентские типизированные прокси-классы для вызова этих API-контроллеров. 

## Введение

### «Скомпилировалось — значит, работает»

----
`undefined is not a function`

----
Только не во frontend-коде?

----
Типизация в мире фронтенда как средство повышения качества кода. 
Основная проблема типизации — ее отсутствие во внешнем мире. 

Для фронтенд-кода внешний мир это:
- нетипизированные библиотеки (решается тайпингами, и почти для всего уже есть) и 
- взаимодействие с сервером. 

Но на сервере уже есть типизация, почему бы не прокинуть мостик системы типов между клиентом и сервером? 

## Инфраструктурное решение

### Контекст

Пусть мы говорим про `ASP.NET` приложение. Неважно, это Core или классический  MVC, так и или иначе есть набор контроллеров, которые отдают представления (`UI-контроллеры`), и есть набор контроллеров, которые принимаю и отдают JSON-объекты (`API-контроллеры`). Клиентский код имеет дело как с первыми, так и со вторыми. Какие точки взаимодействия между клиентом и сервером там есть? 

### Точки сборки-1

`UI-контроллеры` рендерят состояние страницы, и если при этом нужно инициализировать некоторые `клиентские объекты` (например, `React-компонент`) и передать туда начальное состояние в виде JSON, то этот JSON должен подготовить UI-контроллер. Это первая типичная точка взаимодействия.

### Точки сборки-2

`API-контроллеры` принимают запросы и отдают ответы, и запрос исходит, а ответ приходит в `клиентский объект` (например, `Store`), это вторая и третья точки взаимодействия. 

### Проблема: разные ожидания

На каждой из точек, надо убедиться, что представления того, кто пишет серверный и кто пишет клиентский код совпадают относительно набора полей, их имён, типов и семантики. 

### Шаг1: определение контракта
Первым шагом для этого в случае типизированного кода на клиенте будет генерация контрактов для передаваемых объектов. Такие контракты нужны независимо от типизации, ведь как-то серверный разработчик должен сообщить клиентскому, какие данные ожидает получить или передает. Иногда направление обратное —  фронтендер делает UI и задает контракты, которые должен выполнить сервер для  работы с ним. 

Но в случае TypeScript это контракты будут не просто описаны, но и автоматически проверяться при написании кода, использующего эти данные. 

### Шаг1: определение контракта - пример контракта

Например, имея вот такой класс на сервере: 

{% highlight C# %}
public class Lesson {
 public string CourseName { get;set; }
 public DateTime StartsAt { get;set; }
}
{% endhighlight %}            

и в предположении, что есть некий LessonController, который дает список уроков: 

{% highlight C# %}
public class LessonController {
  public Lesson[] ListIn(DateTime date) { ... } 
}
{% endhighlight %}            

Мы могли бы на клиенте описать тип 

{% highlight TypeScript %}
interface ILesson {
  courseName: string;
  startsAt: string (*)
}
{% endhighlight %}            

который бы задавал этот контракт. 

* В данном случае мы также отражаем тот факт, что стандартный сериализатор передает  DateTime как строку. 

### Шаг1: определение контракта - польза от типизированного контракта

Наличие такого контракта уже много дает для повышения надежности кода на клиенте: 

{% highlight TypeScript %}
renderLesson(l: Lesson) {
  if (moment(l.startsAt).isAfter(moment()) {
    <span>{l.couseName.toLowerCase()}</span>
  }
}
{% endhighlight %}            

- видите ошибку с `undefined`?

Тут мы получим не ошибку с undefined в интерфейсе, который потребует ручного тестирования для ее выявления, а ошибку времени сборки, которую немедленно обнаружит и исправит разработчик. 

{% highlight TypeScript %}
renderLesson(l: Lesson) {
  if (moment(l.startsAt).isAfter(moment()) {
    <span>{l.courseName.toLowerCase()}</span>
  }
}
{% endhighlight %}            

- компилятор — видит

### Шаг 2: прокси для контроллеров

Но это только начало того, что теперь можно извлечь из этого подхода. 

Генерация прокси для API-контроллеров на клиенте — следующее очевидное улучшение. Это завершает описание контракта для клиента, фиксируя четко названия методов (адрес точки вызова), и типы передаваемых и возвращаемых параметров. 

### Шаг 2: прокси для контроллеров - вопросы

Для того, чтобы сгенерерировать код для контроллеров, надо принять несколько больше решений — например, как посылать http-запросы, какие промисы использовать для выражения ответов. 

### Шаг 2: прокси для контроллеров - возможности

Но можно извлечь большую пользу из такого слоя, в частности, сделать так, чтобы он не только фиксировал типы передаваемых объектов, но и преобразовывал их в вид, удобный для работы на клиенте. 

### Шаг 2: прокси для контроллеров - пример

Например, преобразование даты из строки или int в принятый в вашем проекте формат, например, momentJS. И обратное преобразование в строку при вызове сервера. 

В этом случае можно синхронно изменить тип в контракте и в коде преобразования, и получить такой код на клиенте: 

{% highlight TypeScript %}
interface ILesson {
  courseName: string;
  startsAt: Moment;
}

class LessonControllerProxy { ...
  public listIn(date: moment.Moment) : Promise<ILesson[]>
  {
    const params = `time=${fromClient(data).__dt}`;
    return this.http.post(`/api/Lesson/ListIn?${params}`, {})
      .then((response: { data: any}) => { return fromServer(response.data) as ILessonView[]; });
   }
}
{% endhighlight %}            

### Шаг 2: прокси для контроллеров - еще пример, на миллион долларов

Важно один раз обеспечить одинаковые преобразования типов с сервера на клиента с такими же преобразованиями данных в сериализаторе, и далее можно полагаться на TypeScript в контроле контрактов. 

Например, в проекте используется запрет null внутри ядра системы, для выражения необязательности используется одна из реализаций option type — Maybe<T>. 


{% highlight C# %}
class Person {
  public Maybe<string> Phone {get;set;}
}
{% endhighlight %}            

### Шаг 2: прокси для контроллеров - TypeScript уже решил проблему `null`, в отличие от C#

И при отображении на клиент этот тип `Maybe<T>` преобразуется в `T | null`. Так что если у нас есть свойство "необязательная строка" на сервере в модели, как выше, то на клиенте оно отобразится как: 

{% highlight TypeScript %}
interface IPerson {

  phone: string | null;

}
{% endhighlight %}            

### Шаг 2: прокси для контроллеров - TypeScript уже решил проблему `null`, в отличие от C# - 2

И попытка передать его туда, где требуется строка: 

{% highlight TypeScript %}
const renderTelLink = (phone: string) => (<a href={`tel:${phone}`}>{phone}</a>);

<div>{renderTelLink(user.phone)}</div>
{% endhighlight %}            


даст ошибку компиляции, мы будем вынуждены не забыть проверить, что телефон правда есть: 


{% highlight TypeScript %}
{user.phone !== null 
  ? <div>{renderTelLink(user.phone)}</div>
  : <div>телефон не указан</div>
}
{% endhighlight %}            

## Средства для генерация прокси-слоя на TypeScript для ASP.NET MVC API

Чтобы получить такие сгенерированные типизации в клиентском коде, есть целое множество утилит на текущий день: 
- TypeLite http://type.litesolutions.net/doc (только контракты, не код)
- TypeRpc https://github.com/Rodris/TypedRpc 
- Swagger Codegen https://swagger.io/swagger-codegen/
- Typewriter http://frhagn.github.io/Typewriter/pages/examples.html 
- Reinforced.Typings https://github.com/reinforced/Reinforced.Typings


## Архитектурные рекомендации

Предположим, мы имеем модель DDD в серверном коде, инкапсулированную в слое сервисов, которые могут выполнять бизнес-операции и выдавать результаты прикладных запросов в виде набором доменных объектов и значений. 

### Независимость контрактов от доменной модели

Во-первых, сразу надо осознать, что эти объекты не должны выходить даже и за слой сервисов особо, но уже совершенно точно их не нужно передавать на клиент. 

Контракты front-back взаимодействия — дело исключительно Web-слоя вашего приложения, а никак не доменной области. 

### Независимость контрактов от доменной модели - пример

{% highlight C# %}
// domain class
public class Lesson {
    public Lesson(...) {}
}

// web app: contract
public class LessonView {
    public static LessonView FromDomain(Lesson l) => new LessonView(l.Id, ...);

    // props
}

public class LessonView(Guid id, CourseView course, ...) {
    public static LessonView FromDomain(Lesson l) => new LessonView(l.Id, ...);
}

{% endhighlight %}            

### Независимость контрактов от доменной модели - пример 2

В случае такого разделения, когда для другой страницы потребуется несколько иное представление урока, мы его добавим, не испытывая греховного соблазна добавить ненужные свойства и данные в исходный доменный объект Lesson:

{% highlight C# %}

public class LessonForReportView(Guid id, AdditionalData data) {
    public static LessonForReportView FromDomain(Lesson l) => new LessonView(l.Id, ...);
}

{% endhighlight %}            

# Выводы

Что получаем: 
- четко (типизированно) определенные контракты между клиентом и сервером
- автоматическая генерация клиентского кода для обращений к серверу, со строго типизированными параметрами и возвращаемыми через Promise значениями
- в том числе автоматическое преобразование данных на клиенте в единообразный и удобный формате (даты в MomentJS, option None в null, Guid в string и т.п.) и автоматическое обратное преобразование в серверный формат при вызове сервера
- автоматическая генерация модели данных для клиента

При использовании на клиенте типизированного шаблонизатора, например TypeScript и React, 
- сквозная проверка при компиляции кода от клиента до сервера, 
- тотальное снижение числа традиционных ошибок c «undefined», обусловленных рассинхронизацией представления о данных между клиентом и сервером
