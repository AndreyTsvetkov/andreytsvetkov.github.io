# Делаем клиента на TypeScript и получаем клиентский слой сервисов бесплатно. 

Краткая суть: выражаем все взаимодействие между клиентом и сервером в виде API-контроллеров, по ним генерируем все контракты передаваемых объектов, и по ним же генерируем клиентские типизированные прокси-классы для вызова этих API-контроллеров. 

## Вступление 

Типизация в мире фронтенда как средство повышения качества кода. 
Проблемы типизации — ее отсутствие во внешнем мире: нетипизированные библиотеки (решается тайпингами, и почти для всего уже есть) и взаимодействие с сервером. 
Но на сервере уже есть типизация, почему бы не прокинуть мостик системы типов между клиентом и сервером? 

Инфраструктурное решение

Пусть мы говорим про ASP.NET приложение. Неважно, это Core или классический  MVC, так и или иначе есть набор контроллеров, которые отдают представления (UI-контроллеры), и есть набор контроллеров, которые принимаю и отдают JSON-объекты (API-контроллеры). Клиентский код имеет дело как с первыми, так и со вторыми. Какие точки взаимодействия между клиентом и сервером там есть? 

Первые рендерят состояние страницы, и если при этом нужно инициализировать некоторые клиентские объекты (например, React-компонент) и передать туда начальное состояние в виде JSON, то этот JSON должен подготовить UI-контроллер. Это первая типичная точка взаимодействия.

Вторые принимают запросы и отдают ответы, и запрос исходит, а ответ приходит в клиентский объект, это вторая и третья точки взаимодействия. 

На каждой из них, надо убедиться, что представления того, кто пишет серверный и кто пишет клиентский код совпадают относительно набора, имен и типов полей. 

Первым шагом для этого в случае типизированного кода на клиенте будет генерация контрактов для передаваемых объектов. Такие контракты нужны независимо от типизации, ведь как-то серверный разработчик должен сообщить клиентскому, какие данные ожидает получить или передает. Иногда направление обратное —  фронтендер делает UI и задает контракты, которые должен выполнить сервер для  работы с ним. 

Но в случае TypeScript это контракты будут не просто описаны, но и автоматически проверяться при написании кода, использующего эти данные. 

Например, имея вот такой класс на сервере: 

public class Lesson {
 public string CourseName { get;set; }
 public DateTime StartsAt { get;set; }
}

и в предположении, что есть некий LessonController, который дает список уроков: 

public class LessonController {
  public Lesson[] ListIn(DateTime date) { ... } 
}

Мы могли бы на клиенте описать тип 

interface ILesson {
  courseName: string;
  startsAt: string (*)
}

который бы задавал этот контракт. 

* В данном случае мы также отражаем тот факт, что стандартный сериализатор передает  DateTime как строку. 

Наличие такого контракта уже много дает для повышения надежности кода на клиенте: 

renderLesson(l: Lesson) {
  if (moment(l.startsAt).isAfter(moment()) {
    <span>{l.couseName.toLowerCase()}</span>
  }
}

Тут мы получим не ошибку с undefined в интерфейсе, который потребует ручного тестирования для ее выявления, а ошибку времени сборки, которую немедленно обнаружит и исправит разработчик. 

renderLesson(l: Lesson) {
  if (moment(l.startsAt).isAfter(moment()) {
    <span>{l.courseName.toLowerCase()}</span>
  }
}

Но это только начало того, что теперь можно извлечь из этого подхода. 

Генерация прокси для API-контроллеров на клиенте
 — следующее очевидное улучшение. Это завершает описание контракта для клиента, фиксируя четко названия методов (адрес точки вызова), и типы передаваемых и возвращаемых параметров. 

Для того, чтобы сгенерерировать код для контроллеров, надо принять несколько больше решений — например, как посылать http-запросы, какие промисы использовать для выражения ответов. 

Но можно извлечь большую пользу из такого слоя, в частности, сделать так, чтобы он не только фиксировал типы передаваемых объектов, но и преобразовывал их в вид, удобный для работы на клиенте. 

Например, преобразование даты из строки или int в принятый в вашем проекте формата, например, momentJS и обратное в строку при вызове сервера. 

В этом случае можно синхронно изменить тип в контракте и в коде преобразования, и получить такой код на клиенте: 

interface ILesson {
  courseName: string;
  startsAt: Moment;
}

class LessonControllerProxy { ...
  public listIn(date: moment.Moment) : Promise<ILesson[]>
  {
    const params = `time=${fromClient(data).__dt}`;
    return this.http.post(`/api/Lesson/ListIn?${params}`, {})
      .then((response: { data: any}) => { return fromServer(response.data) as ILessonView[]; });
   }
}



Важно один раз обеспечить одинаковые преобразования типов с сервера на клиента с такими же преобразованиями данных в сериализаторе, и далее можно полагаться на TypeScript в контроле контрактов. 



Например, в проекте используется запрет null внутри ядра системы, для выражения необязательности используется одна из реализаций option type — Maybe<T>. 





class Person {

  public Maybe<string> Phone {get;set;}

}



И при отображении на клиент этот тип `Maybe<T>` преобразуется в `T | null`. Так что если у нас есть свойство "необязательная строка" на сервере в модели, как выше, то на клиенте оно отобразится как: 



interface IPerson {

  phone: string | null;

}



И попытка передать его туда, где  требуется строка: 



const renderTelLink = (phone: string) => (<a href={`tel:${phone}`}>{phone}</a>);



<div>{renderTelLink(user.phone)}</div>



даст ошибку компиляции, мы будем вынуждены не забыть проверить, что телефон правда есть: 



{user.phone !== null 

  ? <div>{renderTelLink(user.phone)}</div>

  : <div>телефон не указан</div>

}

Средства:

Чтобы получить такие сгенерированные типизации в клиентском коде, есть целое множество средств на текущий день: 
- TypeLite http://type.litesolutions.net/doc (только контракты, не код)
- TypeRpc https://github.com/Rodris/TypedRpc 
- Swagger Codegen https://swagger.io/swagger-codegen/
- Typewriter http://frhagn.github.io/Typewriter/pages/examples.html 
- Reinforced.Typings https://github.com/reinforced/Reinforced.Typings


Архитектурное решение

Предположим, мы имеем модель DDD в серверном коде, инкапсулированная в слое сервисов, которые могут выполнять бизнес-операции и выдавать результаты прикладных запросов в виде набором доменных объектов и значений. 

Во-первых

Что получаем: 
- четко (типизированно) определенные контракты между клиентом и сервером
- автоматическая генерация клиентского кода для обращений к серверу, со строго типизированными параметрами и возвращаемыми через Promise значениями
- в том числе автоматическое преобразование данных на клиенте в единообразный и удобный формате (даты в MomentJS, option None в null, Guid в string и т.п.) и автоматическое обратное преобразование в серверный формат при вызове сервера
- автоматическая генерация модели данных для клиента

При использовании на клиенте типизированного шаблонизатора, например TypeScript и React, 
- сквозная проверка при компиляции кода от клиента до сервера, 
- тотальное снижение числа традиционных ошибок c «undefined», обусловленных рассинхронизацией представления о данных между клиентом и сервером
